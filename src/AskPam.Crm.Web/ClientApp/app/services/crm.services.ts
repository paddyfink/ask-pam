/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.13.1.0 (NJsonSchema v9.10.19.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpResponseBase, HttpErrorResponse } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    login(loginModel: LoginDto | null): Observable<AuthInfoDto | null> {
        let url_ = this.baseUrl + "/api/Account/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processLogin(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<AuthInfoDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<AuthInfoDto | null>><any>Observable.throw(response_);
        });
    }

    protected processLogin(response: HttpResponseBase): Observable<AuthInfoDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AuthInfoDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <AuthInfoDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result401: any = null;
            result401 = _responseText === "" ? null : <AuthInfoDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AuthInfoDto | null>(<any>null);
    }

    getInfo(): Observable<AccountInfo | null> {
        let url_ = this.baseUrl + "/api/Account/account/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetInfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfo(<any>response_);
                } catch (e) {
                    return <Observable<AccountInfo | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<AccountInfo | null>><any>Observable.throw(response_);
        });
    }

    protected processGetInfo(response: HttpResponseBase): Observable<AccountInfo | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AccountInfo>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AccountInfo | null>(<any>null);
    }

    forgetPassword(email: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/ForgetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(email);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processForgetPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgetPassword(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processForgetPassword(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    getProfile(): Observable<ProfileDto | null> {
        let url_ = this.baseUrl + "/api/Account/GetProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetProfile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfile(<any>response_);
                } catch (e) {
                    return <Observable<ProfileDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProfileDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetProfile(response: HttpResponseBase): Observable<ProfileDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProfileDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ProfileDto | null>(<any>null);
    }

    setDefaultOrgnization(organizationId: string): Observable<string[] | null> {
        let url_ = this.baseUrl + "/api/Account/SetDefaultOrgnization?";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined and cannot be null.");
        else
            url_ += "organizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSetDefaultOrgnization(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultOrgnization(<any>response_);
                } catch (e) {
                    return <Observable<string[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<string[] | null>><any>Observable.throw(response_);
        });
    }

    protected processSetDefaultOrgnization(response: HttpResponseBase): Observable<string[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string[]>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<string[] | null>(<any>null);
    }

    getProfilePicture(): Observable<ProfilePictureDto | null> {
        let url_ = this.baseUrl + "/api/Account/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<ProfilePictureDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProfilePictureDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<ProfilePictureDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProfilePictureDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ProfilePictureDto | null>(<any>null);
    }

    updateProfile(dto: ProfileDto | null): Observable<ProfileDto | null> {
        let url_ = this.baseUrl + "/api/Account/UpdateProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateProfile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfile(<any>response_);
                } catch (e) {
                    return <Observable<ProfileDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProfileDto | null>><any>Observable.throw(response_);
        });
    }

    protected processUpdateProfile(response: HttpResponseBase): Observable<ProfileDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProfileDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ProfileDto | null>(<any>null);
    }

    getEmailSettings(): Observable<EmailSettingsDto | null> {
        let url_ = this.baseUrl + "/api/Account/GetEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEmailSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailSettings(<any>response_);
                } catch (e) {
                    return <Observable<EmailSettingsDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<EmailSettingsDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetEmailSettings(response: HttpResponseBase): Observable<EmailSettingsDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EmailSettingsDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EmailSettingsDto | null>(<any>null);
    }

    updateEmailSettings(dto: EmailSettingsDto | null): Observable<ProfileDto | null> {
        let url_ = this.baseUrl + "/api/Account/UpdateEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateEmailSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmailSettings(<any>response_);
                } catch (e) {
                    return <Observable<ProfileDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProfileDto | null>><any>Observable.throw(response_);
        });
    }

    protected processUpdateEmailSettings(response: HttpResponseBase): Observable<ProfileDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProfileDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ProfileDto | null>(<any>null);
    }

    changePassword(password: string | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Account/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(password);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processChangePassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>Observable.throw(e);
                }
            } else
                return <Observable<boolean>><any>Observable.throw(response_);
        });
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<boolean>(<any>null);
    }
}

@Injectable()
export class OrganizationSettingsService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getWidgetSettings(): Observable<WidgetSettingsDto | null> {
        let url_ = this.baseUrl + "/api/OrganizationSettings/GetWidgetSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetWidgetSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWidgetSettings(<any>response_);
                } catch (e) {
                    return <Observable<WidgetSettingsDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<WidgetSettingsDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetWidgetSettings(response: HttpResponseBase): Observable<WidgetSettingsDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <WidgetSettingsDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<WidgetSettingsDto | null>(<any>null);
    }

    getEmailSettings(): Observable<EmailOrganizationSettingsDto | null> {
        let url_ = this.baseUrl + "/api/OrganizationSettings/GetEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEmailSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailSettings(<any>response_);
                } catch (e) {
                    return <Observable<EmailOrganizationSettingsDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<EmailOrganizationSettingsDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetEmailSettings(response: HttpResponseBase): Observable<EmailOrganizationSettingsDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EmailOrganizationSettingsDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EmailOrganizationSettingsDto | null>(<any>null);
    }

    updateEmailSettings(settings: EmailOrganizationSettingsDto | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/OrganizationSettings/UpdateEmailSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateEmailSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmailSettings(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processUpdateEmailSettings(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    deleteIntegration(id: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/OrganizationSettings/DeleteIntegration?";
        if (id === undefined)
            throw new Error("The parameter 'id' must be defined.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteIntegration(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteIntegration(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processDeleteIntegration(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    createEmail(email: string | null): Observable<EmailOrganizationSettingsDto | null> {
        let url_ = this.baseUrl + "/api/OrganizationSettings/CreateEmail?";
        if (email === undefined)
            throw new Error("The parameter 'email' must be defined.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEmail(<any>response_);
                } catch (e) {
                    return <Observable<EmailOrganizationSettingsDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<EmailOrganizationSettingsDto | null>><any>Observable.throw(response_);
        });
    }

    protected processCreateEmail(response: HttpResponseBase): Observable<EmailOrganizationSettingsDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EmailOrganizationSettingsDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EmailOrganizationSettingsDto | null>(<any>null);
    }

    getBotSettings(): Observable<BotSettingsDto | null> {
        let url_ = this.baseUrl + "/api/OrganizationSettings/GetBotSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetBotSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBotSettings(<any>response_);
                } catch (e) {
                    return <Observable<BotSettingsDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<BotSettingsDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetBotSettings(response: HttpResponseBase): Observable<BotSettingsDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BotSettingsDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<BotSettingsDto | null>(<any>null);
    }

    updateBotSettings(dto: BotSettingsDto | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/OrganizationSettings/UpdateBotSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateBotSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBotSettings(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processUpdateBotSettings(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    saveQnAs(dto: QnAPairDto[] | null): Observable<QnAPairDto[] | null> {
        let url_ = this.baseUrl + "/api/OrganizationSettings/SaveQnAs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSaveQnAs(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveQnAs(<any>response_);
                } catch (e) {
                    return <Observable<QnAPairDto[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<QnAPairDto[] | null>><any>Observable.throw(response_);
        });
    }

    protected processSaveQnAs(response: HttpResponseBase): Observable<QnAPairDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <QnAPairDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<QnAPairDto[] | null>(<any>null);
    }

    getQnas(input: QnAPairRequestDto | null): Observable<PagedResultDtoOfQnAPairDto | null> {
        let url_ = this.baseUrl + "/api/OrganizationSettings/GetQnas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetQnas(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQnas(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQnAPairDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfQnAPairDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetQnas(response: HttpResponseBase): Observable<PagedResultDtoOfQnAPairDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedResultDtoOfQnAPairDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfQnAPairDto | null>(<any>null);
    }

    ask(question: string | null): Observable<QnAMakerResultDto | null> {
        let url_ = this.baseUrl + "/api/OrganizationSettings/Ask?";
        if (question === undefined)
            throw new Error("The parameter 'question' must be defined.");
        else
            url_ += "question=" + encodeURIComponent("" + question) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processAsk(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsk(<any>response_);
                } catch (e) {
                    return <Observable<QnAMakerResultDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<QnAMakerResultDto | null>><any>Observable.throw(response_);
        });
    }

    protected processAsk(response: HttpResponseBase): Observable<QnAMakerResultDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <QnAMakerResultDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<QnAMakerResultDto | null>(<any>null);
    }
}

@Injectable()
export class SettingsService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getAppSettings(): Observable<AppSettingsDto | null> {
        let url_ = this.baseUrl + "/api/Settings/GetAppSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAppSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettings(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingsDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<AppSettingsDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetAppSettings(response: HttpResponseBase): Observable<AppSettingsDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AppSettingsDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AppSettingsDto | null>(<any>null);
    }

    getSettings(input: SettingsRequestDto | null): Observable<SettingDto[] | null> {
        let url_ = this.baseUrl + "/api/Settings/GetSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettings(<any>response_);
                } catch (e) {
                    return <Observable<SettingDto[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<SettingDto[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetSettings(response: HttpResponseBase): Observable<SettingDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SettingDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SettingDto[] | null>(<any>null);
    }

    updateSettings(setting: SettingDto | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Settings/UpdateSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setting);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSettings(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processUpdateSettings(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }
}

@Injectable()
export class ContactsService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    createContact(contactDto: ContactDto | null): Observable<ContactDto | null> {
        let url_ = this.baseUrl + "/api/Contacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contactDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateContact(<any>response_);
                } catch (e) {
                    return <Observable<ContactDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContactDto | null>><any>Observable.throw(response_);
        });
    }

    protected processCreateContact(response: HttpResponseBase): Observable<ContactDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContactDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContactDto | null>(<any>null);
    }

    patchContact(id: number, contactDto: any | null): Observable<ContactDto | null> {
        let url_ = this.baseUrl + "/api/Contacts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contactDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).flatMap((response_ : any) => {
            return this.processPatchContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatchContact(<any>response_);
                } catch (e) {
                    return <Observable<ContactDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContactDto | null>><any>Observable.throw(response_);
        });
    }

    protected processPatchContact(response: HttpResponseBase): Observable<ContactDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContactDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContactDto | null>(<any>null);
    }

    updateContact(id: number, contactDto: ContactDto | null): Observable<ContactDto | null> {
        let url_ = this.baseUrl + "/api/Contacts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contactDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContact(<any>response_);
                } catch (e) {
                    return <Observable<ContactDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContactDto | null>><any>Observable.throw(response_);
        });
    }

    protected processUpdateContact(response: HttpResponseBase): Observable<ContactDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContactDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContactDto | null>(<any>null);
    }

    getContact(id: number): Observable<ContactDto | null> {
        let url_ = this.baseUrl + "/api/Contacts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContact(<any>response_);
                } catch (e) {
                    return <Observable<ContactDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContactDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetContact(response: HttpResponseBase): Observable<ContactDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContactDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContactDto | null>(<any>null);
    }

    deleteContact(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Contacts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    getContacts(input: ContactListRequestDto | null): Observable<PagedResultDtoOfContactListDto | null> {
        let url_ = this.baseUrl + "/api/Contacts/GetContacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetContacts(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContacts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfContactListDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfContactListDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetContacts(response: HttpResponseBase): Observable<PagedResultDtoOfContactListDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedResultDtoOfContactListDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfContactListDto | null>(<any>null);
    }

    assignToGroup(id: number, groupId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Contacts/{id}/AssignToGroup";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(groupId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processAssignToGroup(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignToGroup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processAssignToGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    getAllRecipients(filter: string | null): Observable<RecipientDto[] | null> {
        let url_ = this.baseUrl + "/api/Contacts/recipients?";
        if (filter === undefined)
            throw new Error("The parameter 'filter' must be defined.");
        else
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAllRecipients(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRecipients(<any>response_);
                } catch (e) {
                    return <Observable<RecipientDto[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<RecipientDto[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetAllRecipients(response: HttpResponseBase): Observable<RecipientDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <RecipientDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<RecipientDto[] | null>(<any>null);
    }

    createGroup(groupDto: ContactGroupDto | null): Observable<ContactGroupDto | null> {
        let url_ = this.baseUrl + "/api/Contacts/groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(groupDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateGroup(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGroup(<any>response_);
                } catch (e) {
                    return <Observable<ContactGroupDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContactGroupDto | null>><any>Observable.throw(response_);
        });
    }

    protected processCreateGroup(response: HttpResponseBase): Observable<ContactGroupDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContactGroupDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContactGroupDto | null>(<any>null);
    }

    getAllGroups(): Observable<ContactGroupDto[] | null> {
        let url_ = this.baseUrl + "/api/Contacts/groups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAllGroups(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGroups(<any>response_);
                } catch (e) {
                    return <Observable<ContactGroupDto[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContactGroupDto[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetAllGroups(response: HttpResponseBase): Observable<ContactGroupDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContactGroupDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContactGroupDto[] | null>(<any>null);
    }

    updateGroup(id: number, groupDto: ContactGroupDto | null): Observable<void> {
        let url_ = this.baseUrl + "/api/Contacts/groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(groupDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateGroup(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGroup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    deleteGroup(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/Contacts/groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteGroup(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGroup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UserSettingsService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getEmailNotificationSettings(): Observable<EmailNotificationSettingsDto | null> {
        let url_ = this.baseUrl + "/api/UserSettings/GetEmailNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEmailNotificationSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<EmailNotificationSettingsDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<EmailNotificationSettingsDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetEmailNotificationSettings(response: HttpResponseBase): Observable<EmailNotificationSettingsDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EmailNotificationSettingsDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EmailNotificationSettingsDto | null>(<any>null);
    }

    updateEmailNotificationSettings(dto: EmailNotificationSettingsDto | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/UserSettings/UpdateEmailNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateEmailNotificationSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmailNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processUpdateEmailNotificationSettings(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }
}

@Injectable()
export class DashboardService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getConversationsAssignedCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/Dashboard/GetConversationsAssignedCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetConversationsAssignedCount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConversationsAssignedCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processGetConversationsAssignedCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    getConversationsUnreadCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/Dashboard/GetConversationsUnreadCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetConversationsUnreadCount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConversationsUnreadCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processGetConversationsUnreadCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    getConversationsFlaggedCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/Dashboard/GetConversationsFlaggedCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetConversationsFlaggedCount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConversationsFlaggedCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processGetConversationsFlaggedCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    getConversationsFollowedCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/Dashboard/GetConversationsFollowedCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetConversationsFollowedCount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConversationsFollowedCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processGetConversationsFollowedCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    getConversationsCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/Dashboard/GetConversationsCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetConversationsCount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConversationsCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processGetConversationsCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    getMessagesReceivedCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/Dashboard/GetMessagesReceivedCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetMessagesReceivedCount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessagesReceivedCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processGetMessagesReceivedCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    getMessagesSentCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/Dashboard/GetMessagesSentCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetMessagesSentCount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessagesSentCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processGetMessagesSentCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    getMessagesUnreadCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/Dashboard/GetMessagesUnreadCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetMessagesUnreadCount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessagesUnreadCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processGetMessagesUnreadCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }
}

@Injectable()
export class FollowersService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    follow(followerRelationDto: FollowerRelationDto | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Followers/Follow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(followerRelationDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processFollow(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFollow(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processFollow(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    unfollow(followerRelationDto: FollowerRelationDto | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Followers/Unfollow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(followerRelationDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUnfollow(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnfollow(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processUnfollow(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    getFollowers(conversationId: number): Observable<UserDto[] | null> {
        let url_ = this.baseUrl + "/api/Followers/GetFollowers?";
        if (conversationId === undefined || conversationId === null)
            throw new Error("The parameter 'conversationId' must be defined and cannot be null.");
        else
            url_ += "conversationId=" + encodeURIComponent("" + conversationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetFollowers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFollowers(<any>response_);
                } catch (e) {
                    return <Observable<UserDto[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserDto[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetFollowers(response: HttpResponseBase): Observable<UserDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserDto[] | null>(<any>null);
    }
}

@Injectable()
export class NotificationsService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getNotifications(input: GetNotificationsRequestDto | null): Observable<PagedResultDtoOfNotificationDto | null> {
        let url_ = this.baseUrl + "/api/Notifications/GetNotifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetNotifications(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotifications(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNotificationDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfNotificationDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetNotifications(response: HttpResponseBase): Observable<PagedResultDtoOfNotificationDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedResultDtoOfNotificationDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfNotificationDto | null>(<any>null);
    }

    getUnreadNotificationsCount(): Observable<number> {
        let url_ = this.baseUrl + "/api/Notifications/unreadcount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetUnreadNotificationsCount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnreadNotificationsCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>Observable.throw(e);
                }
            } else
                return <Observable<number>><any>Observable.throw(response_);
        });
    }

    protected processGetUnreadNotificationsCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <number>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<number>(<any>null);
    }

    read(id: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Notifications/{id}/read";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processRead(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRead(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processRead(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    markAllNotificationAsSeen(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Notifications/markAllAsSeen";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processMarkAllNotificationAsSeen(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllNotificationAsSeen(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processMarkAllNotificationAsSeen(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }
}

@Injectable()
export class UploadService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    uploadProfilePicture(file: FileParameter | null | undefined): Observable<ProfilePictureDto | null> {
        let url_ = this.baseUrl + "/api/upload/UploadProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUploadProfilePicture(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<ProfilePictureDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProfilePictureDto | null>><any>Observable.throw(response_);
        });
    }

    protected processUploadProfilePicture(response: HttpResponseBase): Observable<ProfilePictureDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProfilePictureDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ProfilePictureDto | null>(<any>null);
    }

    resetProfilePicture(): Observable<ProfilePictureDto | null> {
        let url_ = this.baseUrl + "/api/upload/ResetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processResetProfilePicture(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<ProfilePictureDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProfilePictureDto | null>><any>Observable.throw(response_);
        });
    }

    protected processResetProfilePicture(response: HttpResponseBase): Observable<ProfilePictureDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ProfilePictureDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ProfilePictureDto | null>(<any>null);
    }
}

@Injectable()
export class ConversationsService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getConversations(input: ConversationListRequestDto | null): Observable<PagedResultDtoOfConversationListDto | null> {
        let url_ = this.baseUrl + "/api/Conversations/GetConversations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetConversations(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConversations(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfConversationListDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfConversationListDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetConversations(response: HttpResponseBase): Observable<PagedResultDtoOfConversationListDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedResultDtoOfConversationListDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfConversationListDto | null>(<any>null);
    }

    getConversation(id: number): Observable<ConversationDto | null> {
        let url_ = this.baseUrl + "/api/Conversations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetConversation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConversation(<any>response_);
                } catch (e) {
                    return <Observable<ConversationDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ConversationDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetConversation(response: HttpResponseBase): Observable<ConversationDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ConversationDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ConversationDto | null>(<any>null);
    }

    linkContactToConversation(id: number, contactId: number): Observable<ContactDto | null> {
        let url_ = this.baseUrl + "/api/Conversations/{id}/linkContact";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(contactId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processLinkContactToConversation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkContactToConversation(<any>response_);
                } catch (e) {
                    return <Observable<ContactDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContactDto | null>><any>Observable.throw(response_);
        });
    }

    protected processLinkContactToConversation(response: HttpResponseBase): Observable<ContactDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContactDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContactDto | null>(<any>null);
    }

    unlinkContactToConversation(id: number): Observable<ContactDto | null> {
        let url_ = this.baseUrl + "/api/Conversations/{id}/unlinkContact";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUnlinkContactToConversation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkContactToConversation(<any>response_);
                } catch (e) {
                    return <Observable<ContactDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContactDto | null>><any>Observable.throw(response_);
        });
    }

    protected processUnlinkContactToConversation(response: HttpResponseBase): Observable<ContactDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContactDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ContactDto | null>(<any>null);
    }

    assignToUser(id: number, userId: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Conversations/{id}/assign";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processAssignToUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignToUser(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processAssignToUser(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    flag(id: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Conversations/{id}/flag";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processFlag(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFlag(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processFlag(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    star(id: number, isStarred: boolean): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Conversations/{id}/Star";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(isStarred);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processStar(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStar(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processStar(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    markAsUnread(id: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Conversations/{id}/MarkAsUnread";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processMarkAsUnread(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsUnread(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processMarkAsUnread(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    toogleBotActivation(converationId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Conversations/ToogleBotActivation?";
        if (converationId === undefined || converationId === null)
            throw new Error("The parameter 'converationId' must be defined and cannot be null.");
        else
            url_ += "converationId=" + encodeURIComponent("" + converationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processToogleBotActivation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToogleBotActivation(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processToogleBotActivation(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    archive(id: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Conversations/{id}/archive";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processArchive(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processArchive(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processArchive(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    sendMessage(dto: SendMessageDto | null): Observable<MessageDto | null> {
        let url_ = this.baseUrl + "/api/Conversations/message";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSendMessage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMessage(<any>response_);
                } catch (e) {
                    return <Observable<MessageDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<MessageDto | null>><any>Observable.throw(response_);
        });
    }

    protected processSendMessage(response: HttpResponseBase): Observable<MessageDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MessageDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<MessageDto | null>(<any>null);
    }

    getEmail(messageId: number): Observable<EmailDto | null> {
        let url_ = this.baseUrl + "/api/Conversations/email/{messageId}";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmail(<any>response_);
                } catch (e) {
                    return <Observable<EmailDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<EmailDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetEmail(response: HttpResponseBase): Observable<EmailDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EmailDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EmailDto | null>(<any>null);
    }

    getFilters(): Observable<EnumValueDto[] | null> {
        let url_ = this.baseUrl + "/api/Conversations/filters";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetFilters(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilters(<any>response_);
                } catch (e) {
                    return <Observable<EnumValueDto[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<EnumValueDto[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetFilters(response: HttpResponseBase): Observable<EnumValueDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EnumValueDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EnumValueDto[] | null>(<any>null);
    }
}

@Injectable()
export class NotesService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getNotes(request: GetNotesRequestDto | null): Observable<NoteDto[] | null> {
        let url_ = this.baseUrl + "/api/Notes/GetNotes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetNotes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotes(<any>response_);
                } catch (e) {
                    return <Observable<NoteDto[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<NoteDto[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetNotes(response: HttpResponseBase): Observable<NoteDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <NoteDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<NoteDto[] | null>(<any>null);
    }

    createNote(input: NoteDto | null): Observable<NoteDto | null> {
        let url_ = this.baseUrl + "/api/Notes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateNote(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNote(<any>response_);
                } catch (e) {
                    return <Observable<NoteDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<NoteDto | null>><any>Observable.throw(response_);
        });
    }

    protected processCreateNote(response: HttpResponseBase): Observable<NoteDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <NoteDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<NoteDto | null>(<any>null);
    }

    deleteNote(id: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Notes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteNote(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNote(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processDeleteNote(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }
}

@Injectable()
export class LibraryService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    createLibraryItem(input: LibraryItemDto | null): Observable<LibraryItemDto | null> {
        let url_ = this.baseUrl + "/api/Library";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateLibraryItem(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateLibraryItem(<any>response_);
                } catch (e) {
                    return <Observable<LibraryItemDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<LibraryItemDto | null>><any>Observable.throw(response_);
        });
    }

    protected processCreateLibraryItem(response: HttpResponseBase): Observable<LibraryItemDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LibraryItemDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<LibraryItemDto | null>(<any>null);
    }

    updateLibraryItem(id: number, input: LibraryItemDto | null): Observable<LibraryItemDto | null> {
        let url_ = this.baseUrl + "/api/Library/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateLibraryItem(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLibraryItem(<any>response_);
                } catch (e) {
                    return <Observable<LibraryItemDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<LibraryItemDto | null>><any>Observable.throw(response_);
        });
    }

    protected processUpdateLibraryItem(response: HttpResponseBase): Observable<LibraryItemDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LibraryItemDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<LibraryItemDto | null>(<any>null);
    }

    getLibraryItem(id: number): Observable<LibraryItemDto | null> {
        let url_ = this.baseUrl + "/api/Library/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetLibraryItem(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLibraryItem(<any>response_);
                } catch (e) {
                    return <Observable<LibraryItemDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<LibraryItemDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetLibraryItem(response: HttpResponseBase): Observable<LibraryItemDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LibraryItemDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<LibraryItemDto | null>(<any>null);
    }

    deleteLibraryItem(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Library/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteLibraryItem(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLibraryItem(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>Observable.throw(e);
                }
            } else
                return <Observable<boolean>><any>Observable.throw(response_);
        });
    }

    protected processDeleteLibraryItem(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<boolean>(<any>null);
    }

    getLibraryItems(input: LibraryItemListRequestDto | null): Observable<PagedResultDtoOfLibraryItemListDto | null> {
        let url_ = this.baseUrl + "/api/Library/GetLibraryItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetLibraryItems(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLibraryItems(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLibraryItemListDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfLibraryItemListDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetLibraryItems(response: HttpResponseBase): Observable<PagedResultDtoOfLibraryItemListDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedResultDtoOfLibraryItemListDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfLibraryItemListDto | null>(<any>null);
    }

    getLibraryItemTypes(): Observable<LibraryItemTypeDto[] | null> {
        let url_ = this.baseUrl + "/api/Library/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetLibraryItemTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLibraryItemTypes(<any>response_);
                } catch (e) {
                    return <Observable<LibraryItemTypeDto[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<LibraryItemTypeDto[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetLibraryItemTypes(response: HttpResponseBase): Observable<LibraryItemTypeDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LibraryItemTypeDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<LibraryItemTypeDto[] | null>(<any>null);
    }
}

@Injectable()
export class OrganizationService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getFeatures(id: string): Observable<FeaturesDto | null> {
        let url_ = this.baseUrl + "/api/Organization/{id}/features";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetFeatures(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeatures(<any>response_);
                } catch (e) {
                    return <Observable<FeaturesDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FeaturesDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetFeatures(response: HttpResponseBase): Observable<FeaturesDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FeaturesDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FeaturesDto | null>(<any>null);
    }

    getOrganizations(input: GetOrganizationsRequestDto | null): Observable<PagedResultDtoOfOrganizationDto | null> {
        let url_ = this.baseUrl + "/api/Organization/GetOrganizations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetOrganizations(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizations(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetOrganizations(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedResultDtoOfOrganizationDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfOrganizationDto | null>(<any>null);
    }

    createOrganization(input: CreateOrganizationDto | null): Observable<OrganizationDto | null> {
        let url_ = this.baseUrl + "/api/Organization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateOrganization(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganization(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationDto | null>><any>Observable.throw(response_);
        });
    }

    protected processCreateOrganization(response: HttpResponseBase): Observable<OrganizationDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OrganizationDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationDto | null>(<any>null);
    }

    getOrganizationDetail(id: string): Observable<OrganizationDto | null> {
        let url_ = this.baseUrl + "/api/Organization/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetOrganizationDetail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationDetail(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetOrganizationDetail(response: HttpResponseBase): Observable<OrganizationDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OrganizationDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationDto | null>(<any>null);
    }

    getUsers(id: string): Observable<UserDto[] | null> {
        let url_ = this.baseUrl + "/api/Organization/{id}/users";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserDto[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserDto[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetUsers(response: HttpResponseBase): Observable<UserDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserDto[] | null>(<any>null);
    }

    addUser(id: string, input: UserInvitationDto | null): Observable<UserDto | null> {
        let url_ = this.baseUrl + "/api/Organization/{id}/users";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processAddUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUser(<any>response_);
                } catch (e) {
                    return <Observable<UserDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserDto | null>><any>Observable.throw(response_);
        });
    }

    protected processAddUser(response: HttpResponseBase): Observable<UserDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserDto | null>(<any>null);
    }

    removeUser(id: string, userId: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Organization/{id}/users";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processRemoveUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUser(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processRemoveUser(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    createIntegration(id: string, input: IntegrationDto | null): Observable<IntegrationDto | null> {
        let url_ = this.baseUrl + "/api/Organization/{id}/integrations";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateIntegration(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateIntegration(<any>response_);
                } catch (e) {
                    return <Observable<IntegrationDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<IntegrationDto | null>><any>Observable.throw(response_);
        });
    }

    protected processCreateIntegration(response: HttpResponseBase): Observable<IntegrationDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IntegrationDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<IntegrationDto | null>(<any>null);
    }
}

@Injectable()
export class PostsService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    createPost(input: PostDto | null): Observable<PostDto | null> {
        let url_ = this.baseUrl + "/api/Posts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreatePost(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePost(<any>response_);
                } catch (e) {
                    return <Observable<PostDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PostDto | null>><any>Observable.throw(response_);
        });
    }

    protected processCreatePost(response: HttpResponseBase): Observable<PostDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PostDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PostDto | null>(<any>null);
    }

    updatePost(id: number, input: PostDto | null): Observable<PostDto | null> {
        let url_ = this.baseUrl + "/api/Posts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdatePost(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePost(<any>response_);
                } catch (e) {
                    return <Observable<PostDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PostDto | null>><any>Observable.throw(response_);
        });
    }

    protected processUpdatePost(response: HttpResponseBase): Observable<PostDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PostDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PostDto | null>(<any>null);
    }

    getPost(id: number): Observable<PostDto | null> {
        let url_ = this.baseUrl + "/api/Posts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetPost(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPost(<any>response_);
                } catch (e) {
                    return <Observable<PostDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PostDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetPost(response: HttpResponseBase): Observable<PostDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PostDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PostDto | null>(<any>null);
    }

    deletePost(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Posts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeletePost(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>Observable.throw(e);
                }
            } else
                return <Observable<boolean>><any>Observable.throw(response_);
        });
    }

    protected processDeletePost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<boolean>(<any>null);
    }

    getPosts(input: PostListRequestDto | null): Observable<PagedResultDtoOfPostDto | null> {
        let url_ = this.baseUrl + "/api/Posts/GetPosts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetPosts(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPostDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfPostDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetPosts(response: HttpResponseBase): Observable<PagedResultDtoOfPostDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedResultDtoOfPostDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfPostDto | null>(<any>null);
    }
}

@Injectable()
export class TagsService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    tag(tagRelationDto: TagRelationDto | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Tags/Tag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tagRelationDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processTag(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTag(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processTag(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    untag(tagRelationDto: TagRelationDto | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Tags/Untag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tagRelationDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUntag(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUntag(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processUntag(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    getAllTags(): Observable<TagDto[] | null> {
        let url_ = this.baseUrl + "/api/Tags/GetAllTags";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAllTags(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTags(<any>response_);
                } catch (e) {
                    return <Observable<TagDto[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<TagDto[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetAllTags(response: HttpResponseBase): Observable<TagDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TagDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<TagDto[] | null>(<any>null);
    }

    getItemTags(request: GetItemTagsRequestDto | null): Observable<TagDto[] | null> {
        let url_ = this.baseUrl + "/api/Tags/GetItemTags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetItemTags(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItemTags(<any>response_);
                } catch (e) {
                    return <Observable<TagDto[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<TagDto[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetItemTags(response: HttpResponseBase): Observable<TagDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TagDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<TagDto[] | null>(<any>null);
    }

    getAllTagsList(input: TagListRequestDto | null): Observable<PagedResultDtoOfTagListDto | null> {
        let url_ = this.baseUrl + "/api/Tags/GetAllTagsList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGetAllTagsList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTagsList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTagListDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfTagListDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetAllTagsList(response: HttpResponseBase): Observable<PagedResultDtoOfTagListDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedResultDtoOfTagListDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfTagListDto | null>(<any>null);
    }

    getAllCategories(): Observable<string[] | null> {
        let url_ = this.baseUrl + "/api/Tags/GetAllCategories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAllCategories(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCategories(<any>response_);
                } catch (e) {
                    return <Observable<string[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<string[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetAllCategories(response: HttpResponseBase): Observable<string[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string[]>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<string[] | null>(<any>null);
    }

    deleteTag(id: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Tags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteTag(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTag(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processDeleteTag(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    updateTag(id: number, input: TagDto | null): Observable<TagDto | null> {
        let url_ = this.baseUrl + "/api/Tags/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateTag(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTag(<any>response_);
                } catch (e) {
                    return <Observable<TagDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<TagDto | null>><any>Observable.throw(response_);
        });
    }

    protected processUpdateTag(response: HttpResponseBase): Observable<TagDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TagDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<TagDto | null>(<any>null);
    }

    createTag(input: TagDto | null): Observable<TagDto | null> {
        let url_ = this.baseUrl + "/api/Tags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateTag(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTag(<any>response_);
                } catch (e) {
                    return <Observable<TagDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<TagDto | null>><any>Observable.throw(response_);
        });
    }

    protected processCreateTag(response: HttpResponseBase): Observable<TagDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TagDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<TagDto | null>(<any>null);
    }
}

@Injectable()
export class UsersService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getRoles(): Observable<UserRoleDto[] | null> {
        let url_ = this.baseUrl + "/api/Users/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetRoles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<UserRoleDto[] | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserRoleDto[] | null>><any>Observable.throw(response_);
        });
    }

    protected processGetRoles(response: HttpResponseBase): Observable<UserRoleDto[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserRoleDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserRoleDto[] | null>(<any>null);
    }

    assignToRole(id: string, roleName: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Users/{id}/assignToRole";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roleName);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processAssignToRole(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignToRole(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processAssignToRole(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    invite(invitation: UserInvitationDto | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Users/invite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(invitation);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processInvite(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvite(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileResponse | null>><any>Observable.throw(response_);
        });
    }

    protected processInvite(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Observable.of({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileResponse | null>(<any>null);
    }

    getUsers(filter: string | null | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfUserDto | null> {
        let url_ = this.baseUrl + "/api/Users/GetUsers?";
        if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDto | null>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDto | null>><any>Observable.throw(response_);
        });
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserDto | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PagedResultDtoOfUserDto>JSON.parse(_responseText, this.jsonParseReviver);
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfUserDto | null>(<any>null);
    }
}

export interface LoginDto {
    email: string;
    password: string;
}

export interface AuthInfoDto {
    idToken?: string | undefined;
    organizationId?: string | undefined;
}

export interface AccountInfo {
    profile?: ProfileDto | undefined;
    roles?: string[] | undefined;
    organizations?: OrganizationDto[] | undefined;
}

export interface ProfileDto {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    picture?: string | undefined;
}

export interface OrganizationDto {
    id: string;
    name?: string | undefined;
    imageUrl?: string | undefined;
    fullContact: boolean;
    klik: boolean;
    brainDates: boolean;
    stay22: boolean;
    usersCount: number;
    createdAt?: Date | undefined;
}

export interface ProfilePictureDto {
    id?: string | undefined;
    picture?: string | undefined;
}

export interface EmailSettingsDto {
    id?: string | undefined;
    signature?: string | undefined;
}

export interface WidgetSettingsDto {
    smoochAppToken?: string | undefined;
}

export interface EmailOrganizationSettingsDto {
    senderSignatureId?: string | undefined;
    name?: string | undefined;
    email?: string | undefined;
    isDkimVerified: boolean;
    forwardEmail?: string | undefined;
    showPoweredByAskPam: boolean;
}

export interface BotSettingsDto {
    botName: string;
    botAvatar: string;
    intro: string;
    outro: string;
    botEnabled: boolean;
    desactivationEnabled: boolean;
    treshold: number;
}

export interface QnAPairDto {
    id: number;
    question?: string | undefined;
    answer?: string | undefined;
    isDeleted?: boolean | undefined;
}

export interface PagedAndSortedDto {
    maxResultCount: number;
    skipCount: number;
    sorting?: string | undefined;
}

export interface QnAPairRequestDto extends PagedAndSortedDto {
    filter?: string | undefined;
}

export interface PagedResultDtoOfQnAPairDto {
    totalCount: number;
    items?: QnAPairDto[] | undefined;
    hasNext: boolean;
}

export interface QnAMakerResultDto {
    answer?: string | undefined;
    questions?: string[] | undefined;
    score: number;
}

export interface AppSettingsDto {
    intercomAppId?: string | undefined;
}

export interface SettingsRequestDto {
    organizationId?: string | undefined;
    userId?: string | undefined;
}

export interface SettingDto {
    organizationId?: string | undefined;
    organizationName?: string | undefined;
    userId?: string | undefined;
    userFullName?: string | undefined;
    name?: string | undefined;
    value?: string | undefined;
}

export interface FullAuditedDto {
    createdAt?: Date | undefined;
    createdById?: string | undefined;
    modifiedAt?: Date | undefined;
    modifiedById?: string | undefined;
    deletedAt?: Date | undefined;
    deletedById?: string | undefined;
}

export interface ContactDto extends FullAuditedDto {
    id: number;
    genderDisplayName?: string | undefined;
    gender?: string | undefined;
    firstName: string;
    lastName: string;
    fullName?: string | undefined;
    dateOfBirth?: Date | undefined;
    maritalStatus?: string | undefined;
    maritalStatusDisplayName?: string | undefined;
    primaryLanguage?: string | undefined;
    secondaryLanguage?: string | undefined;
    bio?: string | undefined;
    assignedToFullName?: string | undefined;
    publicInfo?: any | undefined;
    data?: any | undefined;
    assignedToId?: string | undefined;
    tags?: TagDto[] | undefined;
    isNew: boolean;
    emailAddress?: string | undefined;
    emailAddress2?: string | undefined;
    address?: AddressDto | undefined;
    mobilePhone?: string | undefined;
    mobilePhoneDisplay?: string | undefined;
    jobTitle?: string | undefined;
    company?: string | undefined;
    businessPhoneNumber?: string | undefined;
    customFields?: any | undefined;
    groupId?: number | undefined;
    groupName?: string | undefined;
}

export interface TagDto {
    id: number;
    name: string;
    category?: string | undefined;
    fullName?: string | undefined;
}

export interface AddressDto {
    address1?: string | undefined;
    address2?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    province?: string | undefined;
    country?: string | undefined;
    fullAddresse?: string | undefined;
}

export interface ContactListRequestDto extends PagedAndSortedDto {
    filter?: string | undefined;
    groupId?: number | undefined;
    userId?: string | undefined;
    withConversation?: boolean | undefined;
}

export interface PagedResultDtoOfContactListDto {
    totalCount: number;
    items?: ContactListDto[] | undefined;
    hasNext: boolean;
}

export interface ContactListDto {
    id: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    groupId: number;
    groupName?: string | undefined;
    tags?: TagDto[] | undefined;
    assignedToFullName?: string | undefined;
    createdAt: Date;
    isNew: boolean;
    conversationsCount: number;
    assignedToDate?: Date | undefined;
    organizationId: string;
}

export interface RecipientDto {
    name?: string | undefined;
    recipient?: string | undefined;
    channelType?: string | undefined;
    contactId: number;
    conversationsCount: number;
}

export interface ContactGroupDto extends FullAuditedDto {
    id: number;
    name?: string | undefined;
    contactsCount: number;
}

export interface EmailNotificationSettingsDto {
    newMessage: boolean;
    newConversation: boolean;
    messageSent: boolean;
    conversationAssigned: boolean;
    contactAssigned: boolean;
    conversationFollowed: boolean;
    conversationFlagged: boolean;
    libraryItemCreated: boolean;
}

export interface FollowerRelationDto {
    userId?: string | undefined;
    conversationId: number;
}

export interface UserDto extends FullAuditedDto {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    email?: string | undefined;
    picture?: string | undefined;
    emailVerified?: boolean | undefined;
    phoneNumber?: string | undefined;
    role?: string | undefined;
}

export interface GetNotificationsRequestDto {
    read?: boolean | undefined;
    skipCount: number;
    maxResultCount: number;
}

export interface PagedResultDtoOfNotificationDto {
    totalCount: number;
    items?: NotificationDto[] | undefined;
    hasNext: boolean;
}

export interface NotificationDto {
    id: number;
    seen: boolean;
    read: boolean;
    data?: string | undefined;
    notificationType?: string | undefined;
    entityType?: string | undefined;
    entityId?: string | undefined;
    createdAt?: Date | undefined;
    description?: string | undefined;
}

export interface LimitedResultRequestDto {
    maxResultCount: number;
}

export interface PagedResultRequestDto extends LimitedResultRequestDto {
    skipCount: number;
}

export interface ConversationListRequestDto extends PagedResultRequestDto {
    filter: string;
    contactId?: number | undefined;
    search?: string | undefined;
}

export interface PagedResultDtoOfConversationListDto {
    totalCount: number;
    items?: ConversationListDto[] | undefined;
    hasNext: boolean;
}

export interface ConversationListDto {
    id: number;
    organizationId: string;
    name?: string | undefined;
    seen: boolean;
    lastMessage?: MessageDto | undefined;
    assignedToId?: string | undefined;
    assignedToFullName?: string | undefined;
    isFlagged: boolean;
    isStarred: boolean;
    createdAt?: Date | undefined;
    date?: Date | undefined;
    avatarColor?: string | undefined;
    isActive?: boolean | undefined;
    botDisabled?: boolean | undefined;
    contact?: SimpleContactDto | undefined;
    channels?: ChannelDto[] | undefined;
    tags?: TagDto[] | undefined;
}

export interface MessageDto {
    id?: number | undefined;
    conversationId: number;
    text?: string | undefined;
    seen: boolean;
    date: Date;
    status?: string | undefined;
    attachmentsCount: number;
    channelType?: string | undefined;
    type?: string | undefined;
    author?: string | undefined;
    authorId?: string | undefined;
    avatar?: string | undefined;
    attachments?: AttachmentDto[] | undefined;
    deliveryStatus?: DeliveryStatusDto[] | undefined;
    tags?: TagDto[] | undefined;
}

export interface AttachmentDto {
    url?: string | undefined;
    name?: string | undefined;
    contentType?: string | undefined;
    contentLength: number;
    content?: string | undefined;
}

export interface DeliveryStatusDto {
    success: boolean;
    open: boolean;
    channelType?: string | undefined;
    errorCode?: string | undefined;
    errorMessage?: string | undefined;
}

export interface SimpleContactDto {
    id: number;
    fullName?: string | undefined;
    emailAddress?: string | undefined;
    mobilePhoneNumber?: string | undefined;
}

export interface ChannelDto {
    id?: number | undefined;
    avatarUrl?: string | undefined;
    smoochId?: string | undefined;
    displayName?: string | undefined;
    type?: string | undefined;
    conversationId?: number | undefined;
}

export interface ConversationDto extends FullAuditedDto {
    id?: number | undefined;
    name?: string | undefined;
    assignedToId?: string | undefined;
    assignedToFullName?: string | undefined;
    assignedToPicture?: string | undefined;
    smoochUserId?: string | undefined;
    email?: string | undefined;
    avatarColor?: string | undefined;
    messages?: MessageDto[] | undefined;
    isActive?: boolean | undefined;
    isFlagged?: boolean | undefined;
    isStarred?: boolean | undefined;
    botDisabled?: boolean | undefined;
    tags?: TagDto[] | undefined;
    contact?: ContactDto | undefined;
    channels?: ChannelDto[] | undefined;
    lastLocation?: Geo | undefined;
}

export interface Geo {
    countryCode?: string | undefined;
    country?: string | undefined;
    regionCode?: string | undefined;
    region?: string | undefined;
    city?: string | undefined;
    zip?: string | undefined;
    latitude: number;
    lontitude: number;
    ip?: string | undefined;
}

export interface SendMessageDto {
    conversationId?: number | undefined;
    cc?: string | undefined;
    bcc?: string | undefined;
    subject?: string | undefined;
    text: string;
    type: string;
    isBodyHtml: boolean;
    attachments?: AttachmentDto[] | undefined;
    recipients?: RecipientDto[] | undefined;
}

export interface EmailDto extends MessageDto {
    to?: string | undefined;
    cc?: string | undefined;
    bcc?: string | undefined;
    from?: string | undefined;
    subject?: string | undefined;
    header?: string | undefined;
    htmlBody?: string | undefined;
    textBody?: string | undefined;
    thread?: string | undefined;
    isReplied: boolean;
    isBodyHtml: boolean;
}

export interface EnumValueDto {
    id?: string | undefined;
    name?: string | undefined;
    default: boolean;
}

export interface GetNotesRequestDto {
    contactId?: number | undefined;
    postId?: number | undefined;
}

export interface NoteDto {
    id?: number | undefined;
    comment?: string | undefined;
    createdAt?: Date | undefined;
    createdById?: string | undefined;
    createdByFullName?: string | undefined;
    createdByPicture?: string | undefined;
    contactId?: number | undefined;
    postId?: number | undefined;
}

export interface LibraryItemDto {
    id?: number | undefined;
    name: string;
    subject?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    description?: string | undefined;
    openingHours?: string | undefined;
    menu?: string | undefined;
    area?: string | undefined;
    price?: string | undefined;
    website?: string | undefined;
    fax?: string | undefined;
    address1?: string | undefined;
    address2?: string | undefined;
    postalCode?: string | undefined;
    city?: string | undefined;
    province?: string | undefined;
    country?: string | undefined;
    type?: string | undefined;
    typeValue?: number | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    isAllDay: boolean;
    tags?: TagDto[] | undefined;
}

export interface LibraryItemListRequestDto extends PagedAndSortedDto {
    filter?: string | undefined;
    libraryTypeId?: number | undefined;
}

export interface PagedResultDtoOfLibraryItemListDto {
    totalCount: number;
    items?: LibraryItemListDto[] | undefined;
    hasNext: boolean;
}

export interface LibraryItemListDto {
    id: number;
    name?: string | undefined;
    subject?: string | undefined;
    nationalPhone?: string | undefined;
    description?: string | undefined;
    website?: string | undefined;
    address1?: string | undefined;
    address2?: string | undefined;
    city?: string | undefined;
    tags?: TagDto[] | undefined;
}

export interface LibraryItemTypeDto {
    id: number;
    name?: string | undefined;
}

export interface FeaturesDto {
    stay22: boolean;
    stay22Event?: string | undefined;
}

export interface GetOrganizationsRequestDto extends PagedAndSortedDto {
    filter?: string | undefined;
}

export interface PagedResultDtoOfOrganizationDto {
    totalCount: number;
    items?: OrganizationDto[] | undefined;
    hasNext: boolean;
}

export interface CreateOrganizationDto {
    name?: string | undefined;
}

export interface IntegrationDto {
    organizationId: string;
    name?: string | undefined;
    channelType?: string | undefined;
    channelTypeId: number;
    username?: string | undefined;
    token?: string | undefined;
    secret?: string | undefined;
    state?: string | undefined;
    postmarkSenderId: number;
    postmarkIsSpfVerified: boolean;
    postmarkIsDkimVerified: boolean;
    isActive: boolean;
}

export interface UserInvitationDto {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email: string;
    roleName: string;
}

export interface PostDto extends FullAuditedDto {
    id: number;
    title?: string | undefined;
    description?: string | undefined;
    createdUserFullName?: string | undefined;
    createdUserPicture?: string | undefined;
    notesCount: number;
    tags?: TagDto[] | undefined;
}

export interface PostListRequestDto extends PagedAndSortedDto {
    filter?: string | undefined;
}

export interface PagedResultDtoOfPostDto {
    totalCount: number;
    items?: PostDto[] | undefined;
    hasNext: boolean;
}

export interface TagRelationDto {
    tagId: number;
    contactId?: number | undefined;
    libraryId?: number | undefined;
    conversationId?: number | undefined;
    messageId?: number | undefined;
}

export interface GetItemTagsRequestDto {
    contactId?: number | undefined;
    libraryId?: number | undefined;
}

export interface TagListRequestDto extends PagedAndSortedDto {
    filter?: string | undefined;
}

export interface PagedResultDtoOfTagListDto {
    totalCount: number;
    items?: TagListDto[] | undefined;
    hasNext: boolean;
}

export interface TagListDto {
    id: number;
    name?: string | undefined;
    category?: string | undefined;
    fullName?: string | undefined;
    createdAt?: Date | undefined;
    contactsCount: number;
    libraryItemsCount: number;
    conversationsCount: number;
}

export interface UserRoleDto {
    id: number;
    organizationId?: string | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
}

export interface PagedResultDtoOfUserDto {
    totalCount: number;
    items?: UserDto[] | undefined;
    hasNext: boolean;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}